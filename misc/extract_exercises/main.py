# IMPORTS
import re
from datetime import datetime

# CONSTANTS
RELATIVE_PATH = "../../book"

AUTOGENERATED_COMMENT = """% THIS DOCUMENT WAS AUTOMATICALLY GENERATED BY THE `extract_exercises` PACKAGE.
% DO NOT EDIT!
"""

# FUNCTIONS
def read_latex_file(path):
    with open(path, "r") as f:
        return f.read()


def get_chapter_files(part_num, ex_or_prob, chapter_id):
    chapter_text = read_latex_file(f"{RELATIVE_PATH}/part{part_num}/{chapter_id}.tex")
    solutions_text = read_latex_file(f"{RELATIVE_PATH}/part{part_num}/{ex_or_prob}-solutions/{chapter_id}.tex")

    return chapter_text, solutions_text

def extract_exercises_and_solutions(ex_or_prob, chapter_text, solutions_text):
    chapter_pattern = re.compile(rf"\\begin{{{ex_or_prob}}}(\[.+\])?(\\index\{{.+\}})?(\\label\{{.+\}})?(?P<content>(.|\s)+?)\\end{{{ex_or_prob}}}", re.MULTILINE)
    solutions_pattern = re.compile(r" {4}\\item(?P<answer>((.|\s)(?!\n {4}\\item)(?!\\end{questions}))+)", re.MULTILINE)

    exercises = []
    for match in chapter_pattern.finditer(chapter_text):
        exercises.append(match.group("content"))

    solutions = []
    for match in solutions_pattern.finditer(solutions_text):
        solutions.append(match.group("answer"))

    return exercises, solutions


def write_exercises_and_solutions(exercises, solutions):
    output = ""
    num = len(exercises)

    if num == 0:
        output = "NIL\n"
    else:
        for i in range(num):
            output += f"\\begin{{mdframed}}\n\\textbf{{{i + 1}.}}"
            output += exercises[i].rstrip()
            output += "\n\\end{mdframed}\n\\textbf{Solution}:\\newline\n"
            output += solutions[i]
            output += "\n"
    
    return output


def write_chapter(part_num, chapter_id):
    output = f"\n\\section{{{chapter_id.replace('-', ' ').title()}}}"
    print(part_num, chapter_id)

    for ex_or_prob in ["exercise", "problem"]:
        output += f"\n\\subsection*{{{ex_or_prob.title()}s}}\n"
        chapter_text, solutions_text = get_chapter_files(part_num, ex_or_prob, chapter_id)
        exercises, solutions = extract_exercises_and_solutions(ex_or_prob, chapter_text, solutions_text)
        output += write_exercises_and_solutions(exercises, solutions)
    
    return output

def get_chapters(book_path):
    with open(book_path, "r") as f:
        content = f.read()
    
    chapter_pattern = re.compile(r"\\include{part(?P<part_num>\d)/(?P<chapter_id>(?!preamble)([\w-]+))}")

    chapters = []
    for match in chapter_pattern.finditer(content):
        chapters.append((match.group("part_num"), match.group("chapter_id")))
    
    return chapters


def generate_exercises_and_solutions(book_path):
    # Get all chapters
    chapters = get_chapters(book_path)

    output = ""
    for part_num, chapter_id in chapters:
        output += write_chapter(part_num, chapter_id)

    return output


# MAIN CODE
# Generate exercise and solutions code
code_to_add = generate_exercises_and_solutions(f"{RELATIVE_PATH}/book.tex")

# Get template
with open("template.txt", "r") as f:
    content = f.read()

# Prepend the comment to before the template's content
content = AUTOGENERATED_COMMENT + "\n" + content

# Update autogenerated date
content = re.sub(r"\\date\{.+\}", rf"\\date{{\\normalsize Generated on\\\\\\large\\code{{{datetime.strftime(datetime.now(), '%Y-%m-%d %H:%M:%S')}}}}}", content)

# Add autogenerated code to the template
insert_point = content.find("\\maketitle") + len("\\maketitle")
content = f"{content[:insert_point]}\n{code_to_add}{content[insert_point:]}"

with open(f"{RELATIVE_PATH}/exercises-only.tex", "w") as f:
    f.write(content)
